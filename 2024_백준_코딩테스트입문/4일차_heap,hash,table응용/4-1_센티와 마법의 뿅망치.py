'''
[문제]

문제
센티는 마법 도구들을 지니고 여행을 떠나는 것이 취미인 악당이다.

거인의 나라에 도착한 센티는 자신보다 키가 크거나 같은 거인들이 있다는 사실이 마음에 들지 않았다.

센티가 꺼내 들은 마법 도구는 바로 마법의 뿅망치로, 
이 뿅망치에 맞은 사람의 키가 ⌊ 뿅망치에 맞은 사람의 키 / 2 ⌋로 변하는 마법 도구이다. 

>> 뿅망치를 맞으면 키/2이 됨

단, 키가 1인 경우 더 줄어들 수가 없어 뿅망치의 영향을 받지 않는다.
>>최소값 1


하지만 마법의 뿅망치는 횟수 제한이 있다. 그래서 센티는 마법의 뿅망치를 효율적으로 사용하기 위한 전략을 수립했다. 바로 매번 가장 키가 큰 거인 가운데 하나를 때리는 것이다.

>>항상 최대값을 값/2로 만듦


과연 센티가 수립한 전략에 맞게 마법의 뿅망치를 이용한다면 거인의 나라의 모든 거인이 센티보다 키가 작도록 할 수 있을까?

[입력]
첫 번째 줄에는 센티를 제외한 거인의 나라의 인구수 N (1 ≤ N ≤ 105)과 
센티의 키를 나타내는 정수 Hcenti (1 ≤ Hcenti ≤ 2 × 109), 
마법의 뿅망치의 횟수 제한 T (1 ≤ T ≤ 105)가 빈칸을 사이에 두고 주어진다. 

두 번째 줄부터 N개의 줄에 각 거인의 키를 나타내는 정수 H (1 ≤ H ≤ 2 × 109)가 주어진다.


[출력]
마법의 뿅망치를 센티의 전략대로 이용하여 거인의 나라의 모든 거인이 센티보다 키가 작도록 할 수 있는 경우, 첫 번째 줄에 YES를 출력하고, 두 번째 줄에 마법의 뿅망치를 최소로 사용한 횟수를 출력한다.

마법의 뿅망치를 센티의 전략대로 남은 횟수 전부 이용하고도 거인의 나라에서 센티보다 키가 크거나 같은 거인이 있는 경우, 첫 번째 줄에 NO를 출력하고, 두 번째 줄에 마법의 뿅망치 사용 이후 거인의 나라에서 키가 가장 큰 거인의 키를 출력한다.

[예제 입력1]
1 10 1 >>센티를 제외한 거인 나라의 인구수 N / 센티의 키 Hcenti / 뿅망치 횟수 제한 T

>>여기서 부터 거인의 키를 나타내는 정수 H
20 

[예제 출력1]
NO
10

[예제 입력2]
2 10 3
16
32

[예제 출력2]
YES
3

'''

import sys, heapq
input = sys.stdin.readline

# 1. 각 데이터 입력받기 
# 시간복잡도: O(1)
n, h, t = map(int, input().split())

# 2. 거인들의 키 heapq 리스트로 저장 

giants = [-int(input()) for _ in range(n)]
heapq.heapify(giants) # 시간복잡도: O(n)


# 망치질 횟수 저장
cnt = 0

# 3. 망치질 횟수만큼 반복
# 시간복잡도: O(log n)
for i in range(t): #O(n log n)
    # 1) 가장 큰 거인이 1명이거나, 센티보다 키가 작을 때 멈춤
    if -giants[0] == 1 or -giants[0] < h:
        break
    else:
        # 그 외에는 peapq에서 제일 큰 값을 /2를 하여 giants에 저장
        # heapreplace 시간복잡도: O(log n)
        heapq.heapreplace(giants, -(-giants[0] // 2))
        # 망치질 횟수 1 증가
        cnt += 1

# 만약 가장 큰 키가 센티보다 크다면?
# 시간복잡도 O(1)
if -giants[0] >= h:
    print('NO', -giants[0], sep='\n')
    # 그 외는?
else:
    print('YES', cnt, sep='\n')



#시작시간: 6:50 / 종료시간: 7:15

'''
[빅 오 표기법 틈새 공부]

1. 힙 생성: O(n)
2. 망치질 반복: O(t·log n)
3. 결과 확인: O(1)
= O(n + t * log n)

전체 시간복잡도: O(n + t * log n)

전체 시간복잡도 계산하는 방법:
병렬인 경우 최악을 가정, 따라서 최고치를 채택
O(n log n)

* t⋅log n이 𝑛의 n보다 큰 경우가 많으므로, 반복문의 영향이 주요한 시간 복잡도를 결정


O(1) :항상 똑같이 빠름! => 시간 변동X
    ex) 책상 위에 있는 1개의 물건 찾기
O(n): 사람이 많을 수록 시간이 늘어남! => 사람의 수에 따라 시간이 유동적으로 변함
    ex) 친구 100명 중에 키가 가장 큰 사람 찾기
        O(n = 100) => 시간 증가
        O(n = 1) => 시간 감소
    
O(n2): 사람이 많을 수록 두배로 오래걸림!
        ex) 친구 100명이 서로 인사하는데, 모든 친구가 모든 친구에게 "안녕!" 하기



'''